---
title: Configure apps
slug: create-apps
section: Create-Apps
hidden: true
---

**Last updated 31st August 2023**



## Objective  

{{% description %}}

![Applications](images/applications.png "0.50")

Within a single project, you can have one or more apps and each app can have multiple instances.
Instances are where the same code can be run with different configurations,
such as one for external communication and one for background processes.
All of the apps and instances are configured with the same syntax.
You can find a [complete reference](./app-reference.md) of all possible settings.

## A minimal application

To create a very basic app, you need a few things:

* A unique `name` not shared by any other app in the project.
* The runtime `type` defining what language it uses.
* A `disk` size for your deployed files.
* A definition of how to handle requests from the outside `web`.

The following example shows such a basic setup for Node.js:

```yaml {configFile="app"}
# The app's name, which must be unique within the project.
{{< code-link destination="/create-apps/app-reference.html#top-level-properties" text="name" >}}: 'app'

# The language and version for your app.
{{< code-link destination="/create-apps/app-reference.html#types" text="type" >}}: 'nodejs:16'

# The size of the app's persistent disk (in MB).
{{< code-link destination="/create-apps/app-reference.html#top-level-properties" text="disk" >}}: 2048

# The app's configuration when it's exposed to the web.
{{< code-link destination="/create-apps/app-reference.html#web" text="web" >}}:
    {{< code-link destination="/create-apps/app-reference.html#locations" text="locations" >}}:
        '/':
            # The public directory relative to the app root.
            root: 'public'
            # Forward resources to the app.
            passthru: true
            # What files to use when serving a directory.
            index: ["index.html"]
            # Allow files even without specified rules.
            allow: true
```

## Use multiple apps

You might have multiple apps you want to run from a single Git repository,
such as a RESTful web service and a front-end or a main website and a blog.
In such cases, you configure each app separately and define the relationships among them.
See the various ways to set up a [multi-app project](./multi-app/_index.md).

## Connect to services

If you want to use one of the [databases or other services {{< vendor/name >}} provides](../add-services/_index.md),
set it up by following these steps:

1\. Configure the service based on the documentation for that service.

1\. Use the information from that service inside your app's [`relationships` definition](./app-reference.md#relationships)

   to configure how your app communicates with the service.

## Control the build and deploy process

Your app generally needs to undergo some steps to be turned from the code in your Git repository into a running app.
If you're running a PHP or Node.js app, this starts with the [build flavor](./app-reference.md#build),
which runs a default set of tasks.
Then any [global dependencies](./app-reference.md#dependencies) can be installed.

Once these optional tasks are done, you can run [hooks](./hooks/_index.md) at various points in the process.
Hooks are places for your custom scripts to control how your app is built and deployed.

## Configure what's served

Once your app is built, it needs a defined way to communicate with the outside world.
Define its behavior with a [`web` instance](./app-reference.md#web).
There you can set what command runs every time your app is restarted,
how dynamic requests are handled, and how to respond with static files.

## Response compression

Response compression reduces payload sizes and generally increases your app's response times.
Dynamic responses generated by your app aren't compressed because of a [general security issue](https://en.wikipedia.org/wiki/BREACH).
While your app can compress its own response,
doing so when the response includes any user-specific information, including a session cookie,
opens up an attack vector over SSL/TLS connections.
For that reason, you generally shouldn't compress generated responses.

Requests for static files that are served directly by {{< vendor/name >}} are compressed automatically
using either gzip or Brotli compression if:

* The request headers for the file support gzip or Brotli compression.
* The file is served directly from disk by {{< vendor/name >}} and not passed through your application.
* The file would be served with a cache expiration time in the future.
* The file type is one of: HTML, JavaScript, JSON, PDF, PostScript, SVG, CSS, CSV, plain text, or XML.

Also, if there is a request for a file and another file exists with the same name plus a `.gz` or `.br` extension,
the compressed file is served regardless of the original file type.
So a request for `styles.css` that accepts a gzipped file (according to the request headers)
automatically returns a `styles.css.gz` file if it exists.
This approach supports any file type and offers some CPU optimization, especially if the cache lifetime is short.

## Comprehensive example

The following example shows a setup for a PHP app with comments to explain the settings.

```yaml {configFile="app"}
# The app's name, which must be unique within the project.
{{< code-link destination="/create-apps/app-reference.html#top-level-properties" text="name" >}}: 'app'

# The language and version for your app.
{{< code-link destination="/create-apps/app-reference.html#types" text="type" >}}: 'php:8.1'

# Global dependencies to be added and cached and then available as commands.
{{< code-link destination="/create-apps/app-reference.html#dependencies" text="dependencies" >}}:
    php:
        composer/composer: '^2'

# The app's relationships (connections) with services or other applications.
# The key is the relationship name that can be viewed in the app.
# The value is specific to how the service is configured.
```json  

```  
    database: 'mysqldb:mysql'

# Scripts that are run as part of the build and deploy process.
{{< code-link destination="/create-apps/hooks.html" text="hooks" >}}:
    # Build hooks can modify app files on disk but not access any services like databases.
    build: ./build.sh
    # Deploy hooks can access services but the file system is now read-only.
    deploy: ./deploy.sh
    # Post deploy hooks run when the app is accepting outside requests.
    post_deploy: ./post_deploy.sh

# The size of the app's persistent disk (in MB).
{{< code-link destination="/create-apps/app-reference.html#top-level-properties" text="disk" >}}: 2048

# Define writable, persistent filesystem mounts.
# The key is the directory path relative to the application root.
# In this case, `web-files` is just a unique name for the mount.
{{< code-link destination="/create-apps/app-reference.html#mounts" text="mounts" >}}:
    'web/files':
        source: local
        source_path: 'web-files'

# The app's configuration when it's exposed to the web.
{{< code-link destination="/create-apps/app-reference.html#web" text="web" >}}:
    {{< code-link destination="/create-apps/app-reference.html#locations" text="locations" >}}:
        '/':
            # The app's public directory relative to its root.
            root: 'public'
            # A front controller to determine how to handle requests.
            passthru: '/app.php'
        # Allow uploaded files to be served, but don't run scripts.
        # Missing files get sent to the front controller.
        '/files':
            root: 'web/files'
            scripts: false
            allow: true
            passthru: '/app.php'
```

---
title: Configure what's served
slug: web
section: App
---

**Last updated 7th January 2022**


## How do I setup a basic PHP application with front-controller?

The following `web` block is a reasonable starting point for a custom PHP application.
It sets the directory `public` as the doc root, and any missing files will get mapped to the `/index.php` file.
mp4 files are forbidden entirely.
Image files from the `images` URL (which will be served from the `/public/images` directory) will have an expiration time set, but non-image files will be disallowed.

```yaml
web:
    locations:
        '/':
            root: 'public'
            passthru: '/index.php'
            index:
                - index.php
            # No caching for static files.
            # (Dynamic pages use whatever cache headers are generated by the program.)
            expires: -1
            scripts: true
            allow: true
            rules:
                # Disallow .mp4 files specifically.
                \.mp4$:
                    allow: false
                    expires: -1
        # Set a 5 min expiration time for static files here; a missing URL
        # will passthru to the '/' location above and hit the application
        # front-controller.
        '/images':
            expires: 300
            passthru: true
            allow: false
            rules:
                # Only allow static image files from the images directory.
                '\.(jpe?g|png|gif|svgz?|ico|bmp)$':
                    allow: true
```

## How can I control the headers sent with my files?

There are many use cases for setting custom headers on static content, such as custom content type headers, limiting cross-origin usage, etc.
Consider the following example:

```yaml
web:
    locations:
        "/":
            root: "public"
            passthru: "/index.php"
            index:
                - index.php
            headers:
              X-Frame-Options: SAMEORIGIN
            rules:
                \.mp4$:
                    headers:
                      X-Frame-Options: SAMEORIGIN
                      Content-Type: video/mp4
                \.mp3$:
                    headers:
                      X-Specialness: low
```

First, the `headers` directive sets the `X-Frame-Options` header to `SAMEORIGIN` for all static files.
That directive is then overridden by the two rules blocks.
For `*.mp4` files, two custom headers will be sent: `X-Frame-Options` and `Content-Type`.
The repeated `X-Frame-Options` is necessary as the `headers` directive in the rule overrides the parent, rather than extending it.
Therefore, the rule for `*.mp3` files will add *only* an `X-Specialness` header, and no `X-Frame-Options` header.

This example also demonstrates an effective way to set custom `Content-Type` headers for unusual file types using rules.

Note that the `headers` directive applies only to static content.
Headers for responses generated by your application are unaffected.
If custom headers for certain file types or frame control are needed, set them from within the application.

## Why is my Access-Control-Allow-Origin header being overwritten?

To allow cross origin requests, the `Access-Control-Allow-Origin` header can be added to responses. However, when this header is configured with the value of `*`, the response headers will be modified in the following ways:

1\. The value of the `Access-Control-Allow-Origin` header will be set to the value of the `Origin` request header.

2\. The `Vary` header will be included, and its value will be set to `Origin`.


This concept is explained in more detail in the [CORS section of the Mozilla Developer Network documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#access-control-allow-origin):

>If the server specifies a single origin (that may dynamically change based on the requesting origin as part of a white-list) rather than the "`*`" wildcard, then the server should also include `Origin` in the `Vary` response header â€” to indicate to clients that server responses will differ based on the value of the `Origin` request header.

This is done so that credentialed requests can be supported, which would otherwise fail CORS checks if the wildcard value is used.

## How can I rewrite an incoming request without a redirect?

Rules blocks support regular expression capture groups that can be referenced in a `passthru` command.
For example, the following configuration will result in requests to `/project/123` being seen by the application as a request to `/index.php?projectid=123` without causing an HTTP redirect.
Note that query parameters present in the request are unaffected and will, unconditionally, appear in the request as seen by the application.

```yaml
web:
    locations:
        '/':
            root: 'public'
            passthru: '/index.php'
            index:
                - index.php
            scripts: true
            allow: true
            rules:
                '^/project/(?<projectid>.*)$':
                    passthru: '/index.php?projectid=$projectid'
```

## How can I serve directories at different paths than in my application?

Although it's common for the directories on disk to be served directly by the web server, that's not actually a requirement.
If desired it is quite possible to create a web URL structure that does not map 1:1 to the structure on disk.

Consider the following example.
The git repository is structured like so:

```text
.platform/
  services.yaml
  routes.yaml
.platform.app.yaml
application/
  conf/
    server.ini
  application.py
gitbook-src/
old-docs/
```

The `application` directory contains a Python application.
The `gitbook-src` directory contains a GitBook project that is the public documentation for the application.
The `old-docs` directory contains a static HTML backup of legacy documentation for an older version of the application that is still needed.

Assume that the GitBook source is compiled by the build process into the `_book` directory, as in the example above.
The following `web` block will:

* Start your Python application using `uwsgi`.
* Route all requests to '/' to the Python application unconditionally, unless one of the following two rules apply.
* Route requests to the `/docs` path to the `_book` directory, which contains our generated documentation, with a short cache lifetime.
* Route requests to the `/docs/legacy` path to the `old-docs` directory, which contains plain old HTML, with a very long cache lifetime since those files should never change.

```yaml
web:
    commands:
        start: 'uwsgi --ini application/conf/server.ini'
    locations:
        '/':
            passthru: true
        '/docs':
            root: '_book'
            index:
                - "index.html"
            expires: 300s
            scripts: false
            allow: true
        '/docs/legacy':
            root: 'old-docs'
            index:
                - "index.html"
            expires: 4w
            scripts: false
            allow: true
```

Even though the URL structure doesn't match the directory names or hierarchy on disk, that's no issue.
It also means the application can safely coexist with static files as if it were a single site hierarchy without the need to mix the static pages in with your Python code.
